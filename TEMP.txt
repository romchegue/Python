def mysum(L):
    if not L:
        return 0
    else:
         return L[0] + mysum(L[1:])


def mysum(L):
    return 0 if not L else L[0] + mysum(L[1:])

def mysum(L):
    return L[0] if len(L) == 1 else L[0] + mysum(L[1:])

def mysum(L):
    fisrt, *rest = L
    return first if not rest else first + mysun(rest)



def sumtree(L):
    tot = 0
    for x in L:
        if not isinstance(x, list):
             tot += x
        else:
             tot += sumtree(x)
    return tot


def myreduce(function, sequence):
    tally = sequence[0]
    for next in sequence[1:]:
        tally = function(tally, next)
    return tally

def extractor(D):
    for key, value in D.items():
        print(key, '\t --->\t', value)
        if not isinstance(value, dict):
            print(key + ':' + value)
        else:
            extractor(value)


for key, value in D.items():
    print(key + ':')
    for key1, value1 in value.items():
        print(' ' * (len(max(D.keys())) + 4), key1 + ':', value1)


M = [[0, 1, 2],
        [3, 4, 5],
        [6, 7, 8]]

N = [[2, 2, 2],
        [3, 3, 3],
        [4, 4, 4]]

res = []
for row in range(3):
    tmp = []
    for col in range(3):
        tmp.append(M[row][col] * N[row][col])
    res.append(tmp)

[M[row][col] * N[row][col] for row in range(3) for col in range(3)]
res = []
for row in range(3):
     for col in range(3):
         res.append(M[row][col] * N[row][col])

def mymap(func, *seqs):
    return [func(*args) for args in zip(*seqs)]

def mymap(func, *seqs):
    for args in zip(*seqs):
        yield func(*args)

def mymap(func, *seqs):
    return (func(*args) for args in zip(*seqs))

def myzip(*seqs):
    print('I got:', seqs)
    seqs = [list(S) for S in seqs]
    res = []
    while all(seqs):
        res.append(tuple(S.pop(0) for S in seqs))
    return res

def mymapPad(*seqs, pad=None):
    seqs = [list(S) for S in seqs]
    res = []
    while any(seqs):
        res.append(tuple((S.pop(0) if S else pad) for S in seqs))
    return res

def myzip(*seqs):
    print('I got:', seqs)
    seqs = [list(S) for S in seqs]
    while all(seqs):
        yield tuple(S.pop(0) for S in seqs)

def mymapPad(*seqs, pad=None):
    seqs = [list(S) for S in seqs]
    while any(seqs):
        yield tuple((S.pop(0) if S else pad) for S in seqs)

def myzip(*seqs):
    minlen = min(len(S) for S in seqs)
    res = []
    for i in range(minlen):
        tmp = []
        for S in seqs:
            tmp.append(S[i])
        res.append(tuple(tmp))
    return res

def myzip(*seqs):
    minlen = min(len(S) for S in seqs)
    return [tuple((S[i]) for S in seqs) for i in range(minlen)]

def mymapPad(*seqs, pad=None):
    maxlen = max(len(S) for S in seqs)
    return [tuple(S[i] if len(S) > i else pad for S in seqs) for i in range(maxlen)]

def myzip(*seqs):
    minlen = min(len(S) for S in seqs)
    return (tuple((S[i]) for S in seqs) for i in range(minlen))

def myzip(*args):
    iters = list(map(iter, args))
    while iters:
        res = [next(i) for i in iters]
        yield tuple(res)

# File mytimer.py
import time
reps = 1000
repslist = range(reps)

def timer(func, *pargs, **kargs):
    start = time.process_time()
    for i in repslist:
        ret = func(*pargs, **kargs)
    elapsed = time.process_time() - start
    return (elapsed, ret)



import sys, mytimer
reps = 10000
repslist = range(reps) 

def forLoop():
    res = []
    for x in repslist:
        res.append(abs(x))
    return res

def listComp():
    return [abs(x) for x in repslist]

def mapCall():
    return list(map(abs, repslist))

def genExpr():
    return list(abs(x) for x in repslist) 

def genFunc():
    def gen():
        for x in repslist:
            yield abs(x)
    return list(gen())

print(sys.version)
for test in (forLoop, listComp, mapCall, genExpr, genFunc):
    elapsed, result = mytimer.timer(test)
    print ('-' * 35)
    print ('%-9s: %.5f => [%s...%s]' % (test.__name__, elapsed, result[0], result[-1]))





